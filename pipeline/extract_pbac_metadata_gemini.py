# pipeline/extract_pbac_metadata_gemini.py

"""
Gemini Metadata Extractor Module
--------------------------------
This script is designed to be called from the main pipeline. It takes a
document path and a configuration dictionary, then uses the Google Gemini API
to extract structured metadata from it.

-   It dynamically reads the model name and token limits from the config.
-   It intelligently determines the file's MIME type before uploading.
-   It uses a configurable request timeout to handle complex documents.
-   It returns the extracted data as a dictionary for the main pipeline to handle.
-   Includes robust JSON parsing and a cleanup step to delete the file from
    Google's servers after processing.
"""
import os
import json
import argparse
import logging
import google.generativeai as genai
from datetime import datetime
from pathlib import Path
from typing import Dict, Any

# Configure the Gemini client once when the module is loaded.
if os.getenv("GOOGLE_API_KEY"):
    genai.configure(api_key=os.getenv("GOOGLE_API_KEY"))

# A mapping of file extensions to their corresponding MIME types for the Gemini API.
MIME_TYPE_MAP = {
    ".pdf": "application/pdf",
    ".docx": "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    ".txt": "text/plain",
    # Add other supported types here as needed
}

system_prompt = """
You are a specialist analyst for the Australian Pharmaceutical Benefits Advisory Committee (PBAC). Your task is to read the provided document and extract structured metadata.

You must respond ONLY with a single, valid JSON object. Do not include any text, notes, or markdown formatting like ```json before or after the JSON object.

The JSON object must contain the following fields:
- doc_id: Leave this as null. It will be generated by the pipeline.
- title: The full, official title of the document.
- doc_type: Classify the document into one of the following categories: [PSD, Guideline, Meeting Outcome, Cost Manual, Consultation Input, Newsletter, Misc].
- submission_type: If applicable, classify into: [New, Resubmission, Deferral, Rejection]. Otherwise, set to null.
- pbac_meeting_date: The date of the PBAC meeting mentioned, in any format you find (e.g., "July 2024", "2024-07-15"). Set to null if not present.
- drug_name: The primary drug or therapeutic product discussed. Set to null if not applicable.
- sponsor: The company or entity that sponsored the submission. Set to null if not applicable.
- indication: The medical condition or reason for using the drug. Set to null if not applicable.
- outcome: The final decision or outcome (e.g., "Recommended", "Rejected", "Deferred"). Set to null if not a decision document.
- topics: A comma-separated string of up to 5 key topics (e.g., "cost-effectiveness, clinical trials, safety data").
- sections: A list of JSON objects, where each object represents a logical section of the document. Each object in the list must have 'heading' and 'text' keys. For example: [{"heading": "1. Introduction", "text": "This is the introduction..."}, {"heading": "2. Clinical Evidence", "text": "The evidence shows..."}]
"""

def extract_metadata(file_path: str, config: Dict[str, Any], logger: logging.Logger) -> Dict[str, Any]:
    """
    Extracts structured metadata from a document using the Gemini API.
    """
    uploaded_file = None
    raw_response_text = ""
    try:
        file_ext = os.path.splitext(file_path)[1].lower()
        mime_type = MIME_TYPE_MAP.get(file_ext)

        if not mime_type:
            err_msg = f"Unsupported file type for Gemini extraction: {file_ext}"
            logger.error(err_msg)
            return {"error": err_msg}

        logger.info(f"Uploading to Gemini API: {os.path.basename(file_path)} with MIME type: {mime_type}")
        uploaded_file = genai.upload_file(
            path=file_path,
            display_name=Path(file_path).name,
            mime_type=mime_type
        )
        logger.info(f"Successfully uploaded file. URI: {uploaded_file.uri}")

        # Read Gemini settings from the config, providing sensible defaults.
        model_name = config.get('gemini_model', 'gemini-1.5-flash-latest')
        max_tokens = config.get('gemini_max_output_tokens', 8192)
        timeout_seconds = config.get('gemini_request_timeout', 120)

        model = genai.GenerativeModel(
            model_name=model_name,
            system_instruction=system_prompt
        )

        generation_config = genai.GenerationConfig(
            response_mime_type="application/json",
            max_output_tokens=max_tokens
        )
        
        request_options = {"timeout": timeout_seconds}
        logger.info(f"Sending request to Gemini model: {model.model_name} with a {timeout_seconds}s timeout...")
        
        response = model.generate_content(
            [uploaded_file, "Please extract the structured data from this document based on my system instructions."],
            generation_config=generation_config,
            request_options=request_options
        )
        
        raw_response_text = response.text
        parsed_data = json.loads(raw_response_text)
        
        parsed_data["source"] = file_path
        parsed_data["extracted_at"] = datetime.now().isoformat()
        
        return parsed_data

    except json.JSONDecodeError as e:
        logger.error(f"JSONDecodeError for {file_path}: {e}. This likely means the API response was incomplete.", exc_info=False)
        logger.debug(f"Malformed response text that caused error: {raw_response_text}")
        return {"error": f"JSONDecodeError: {e}", "raw_response": raw_response_text}
    except Exception as e:
        logger.error(f"Gemini extraction failed for {file_path}: {e}", exc_info=True)
        return {"error": f"Gemini extraction failed: {e}"}
    
    finally:
        if uploaded_file:
            try:
                genai.delete_file(uploaded_file.name)
                logger.info(f"Cleaned up uploaded file from Gemini servers: {uploaded_file.name}")
            except Exception as e:
                logger.warning(f"Could not delete file {uploaded_file.name} from Gemini servers: {e}")

# This block allows the script to be run standalone for testing purposes
if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description="Standalone test for extracting metadata from a document.",
        formatter_class=argparse.RawTextHelpFormatter
    )
    parser.add_argument("--input", required=True, help="Path to the document file to process.")
    parser.add_argument("--output", required=True, help="Path to save the output JSON file.")
    args = parser.parse_args()

    test_logger = logging.getLogger('standalone_test')
    test_logger.addHandler(logging.StreamHandler())
    test_logger.setLevel(logging.INFO)
    
    # Dummy config for standalone mode, mirroring the main config structure
    dummy_config = {
        "gemini_model": "gemini-2.0-flash",
        "gemini_max_output_tokens": 8192,
        "gemini_request_timeout": 120
    }

    test_logger.info("Running in standalone test mode...")
    result = extract_metadata(args.input, dummy_config, test_logger)

    if "error" not in result:
        os.makedirs(os.path.dirname(args.output), exist_ok=True)
        with open(args.output, 'w', encoding='utf-8') as f:
            json.dump(result, f, indent=2)
        test_logger.info(f"✅ Successfully extracted metadata and saved to: {args.output}")
    else:
        test_logger.error(f"❌ Failed to extract metadata. Result: {result}")
